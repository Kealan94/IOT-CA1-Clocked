Clocked Design Document
Introduction
Clocked will be a one or more physical IoT device per business premises and webapp accessible through the internet. Our current focus and Minimum Viable Product (MVP) is to have it work with one device per business premises with scalability being a “should have”.

The device itself in short: will be a touchscreen display for inputting credentials and display current time and feedback on successful or unsuccessful clock and login attempts. The device will also include a Raspberry Pi, we will be testing with the Zero and 4. Preference is for the Zero as it would mean less cost.
These two physical devices will be grouped and called “the device” or “the clock machine”. On the backend they will be connected to an AWS server which will act as a webserver and interact with the SQL database. The webapp will be accessible from anywhere with internet and information will be given on a need-to-know basis. Managers accounts will differ from employees for example. With the webapp employees can check their rota, managers and payroll can check attendance.

The Team
Our group name is Sundial to keep with the theme of time keeping. The work for this project will be delegated as follows:

Sean Stephens (UI , UX and Frontend)
// {Sean}Brief description of role
Ciaran Brennan (IoT, Hardware)
// {Ciaran}Brief description of role
Desmond Madden (Testing of System, Software, Security and UX)
// {Desmond}Brief description of role
My role in this project is to test the System, Software, Security and UX of the device and app and provide feedback and possible solutions to the relevant roles.
Kealan Crilly (System Architect)
// {Kealan}Brief description of role
Finbar Thornton {Backend, Database and Server}
My role will involve programming and designing the backend logic the device will use to communicate with the server and the server with the device, how that data will be stored and ensuring security of the data.




Hardware{Ciaran}
[FRITZING DIAGRAM IMAGE OF CIRCUIT]
// Describe components (Pi, sensors, display), NFC technology, where they’re sourced, if they’re ordered or received. NFC on the smartphone, how reliable components are. Include images of the components How will the device be powered, how will it connect to the internet (WiFi, Internet). Describe what information the device will accept from the outside.
At the end include the work you will be doing.

System{Kealan}
// Talk about the system as a whole, not in as much detail as others topic but enough to have an understanding of the logical layout.
At the end include the work you will be doing.

Backend{Finbar}
// Talk about device logic for communicating with AWS with PubNub, how the data will be sent, how it will be stored once it reaches the server. How will it be secured? Choices for login in credentials, database schema.
At the end include the work you will be doing.

User Interface{Sean}
// Talk about the UI, share pictures of it, design choices. How will the user interact with it? What access will they have? Where can they interface with it? Do managers and employees see the same amount of information?
At the end include the work you will be doing.

Testing{Desmond}
// Pretty much a repeat of the presentation with as much more detail as you want, include how you’ll test, what you’ll test. Security testing. Like Enda brought up, testing from the Managers perspective, its assumed the employee can’t be trusted but not the manager, we should change that. At the end include the work you will be doing.
For this project, we'll have to do multiple waves of testing, doing unit-testing, integration and performance/system tests and then finally user acceptance at the end from both parties (the Employee and the Manager) perspectives. 
So using an AGILE testing methodology would be best as it would mean that we are continuously testing what we are currently doing.
{AGILE image}
This is to make sure the code is working as it should and that it is properly connected and interacting with the other features, such as the terminal, the webserver, and the database, with as little of errors or problems that we can.
Unit-Testing is a way of testing a small segment of code isolated away from the rest of the app, be that a function, method, subroutine, or property, to confirm that it can be executed properly without relying on others.
Anytime a change is made to the code, new unit testing will need to be conducted to ensure that it hasn't negatively affected the current build of the system and so any unknown issues are resolved efficiently and in a timely manner.
Integration is when we start putting all the code together and testing them as a group instead of individually Unit-Testing them. This is to make sure nothing interferes with other parts of the system, unless we have purposefully aimed to make it that way.
Performance or System Testing is when, after integration is all sorted, we put the system under various workloads to test its response time, speed, resource usage and other aspects that might affect the systems overall performance.
During this, I'll also be testing the security of various aspects of the system, trying to break it and or find vulnerabilities and reguraly provide feedback to those in the relevent roles. 
For this, I'll be researching and hopefully using the Operations Security (OPSEC) methodology. OPSEC, is a 5-Step process in which I must indentify critical information, analyze the threat, analyze the vulnerability, access the risks and then apply the appropriate countermeasures. In regards to the system security, notable prioritizing securing the NFC and database aspects of it.
{OPSEC image}
After all the previous test phases are completed, then we can start doing User Acceptance Testing. This is the final phase to be done. This is where we have to get users, most likely friends and or family, to test the system from both employee and manager views and see if they are able to complete a number of tasks in emulated scenarios similar to the envirnoment of its intended use. 
The system must be as easy to use and efficient as possible. We'd need to observe and take note of where the users are clicking or tapping, how the they feel about the size, position and colour of features on the app and webpages.


Personas and Use Cases {Anyone}
// 5 Personas(5 Use cases): Employee (Everything works), Employee (Forgot their phone and password), Employee(New employee being added to the system), Payroll(Adding someone who can’t get clocked in), Manager(Checking on who is in and who is late)






